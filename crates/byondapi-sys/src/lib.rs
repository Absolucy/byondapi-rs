// Ignore style warnings for for byondapi-c bindings
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(clippy::missing_safety_doc)]
#![allow(unused)]

use std::{
    any::Any,
    ffi::{c_char, c_float},
};

#[cfg(not(target_pointer_width = "32"))]
compile_error!("BYOND API only functions with 32-bit targets");

#[cfg(not(target_arch = "x86"))]
compile_error!("BYOND API only functions on x86 targets");

#[cfg(not(any(target_os = "linux", target_os = "windows")))]
compile_error!("BYOND API only supports Windows and Linux");

// Include byondapi-c bindings (generated by build.rs)
mod byond515_1609 {
    include!(concat!(env!("OUT_DIR"), "/bindings_515_1609.rs"));
}
mod byond515_1610 {
    include!(concat!(env!("OUT_DIR"), "/bindings_515_1610.rs"));
}
mod byond515_1611 {
    include!(concat!(env!("OUT_DIR"), "/bindings_515_1611.rs"));
}

/// we must simply hope this never changes
mod version {
    use super::byond515_1609::u4c;

    pub unsafe fn get_byond_version(library: &libloading::Library) -> (u32, u32) {
        let Byond_GetVersion: unsafe extern "C" fn(version: *mut u4c, build: *mut u4c) = library
            .get(b"Byond_GetVersion\0")
            .map(|sym| *sym)
            .expect("Failed to find Byond_GetVersion");

        let mut version = 0;
        let mut build = 0;

        Byond_GetVersion(&mut version, &mut build);

        (version, build)
    }
}

pub struct ByondApi {
    _internal: Box<dyn Any>,
    version: (u32, u32),
}

unsafe impl Sync for ByondApi {}

impl ByondApi {
    pub unsafe fn init_from_library<L>(library: L) -> Result<ByondApi, libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let lib = library.into();
        let version = version::get_byond_version(&lib);

        let _internal: Box<dyn Any> = match version {
            (515, 1609) => Box::new(byond515_1609::ByondApi::from_library(lib)?),
            (515, 1610) => Box::new(byond515_1610::ByondApi::from_library(lib)?),
            (515, 1611..=1612) => Box::new(byond515_1611::ByondApi::from_library(lib)?),
            x => return Err(::libloading::Error::DlSymUnknown),
        };

        Ok(ByondApi { _internal, version })
    }
}

impl ByondApi {
    fn get_lib<T: Any>(&self) -> &T {
        self._internal.downcast_ref().unwrap()
    }
}

// Stabilized types
pub use byond515_1609::s1c;
pub use byond515_1609::s1cMAX;
pub use byond515_1609::s1cMIN;
pub use byond515_1609::s2c;
pub use byond515_1609::s2cMAX;
pub use byond515_1609::s2cMIN;
pub use byond515_1609::s4c;
pub use byond515_1609::s4cMAX;
pub use byond515_1609::s4cMIN;
pub use byond515_1609::s8c;
pub use byond515_1609::u1c;
pub use byond515_1609::u2c;
pub use byond515_1609::u4c;
pub use byond515_1609::u4cOrPointer;
pub use byond515_1609::u8c;
pub use byond515_1609::ByondValueData;
pub use byond515_1609::ByondValueType;
pub use byond515_1609::CByondValue;
pub use byond515_1609::CByondValueList;

pub use byond515_1611::CByondXYZ;

macro_rules! generate_match {
    ($self: ident, $function: ident $(, $arg:expr)*) => {
        match $self.version {
            (515, 1609) => $self
                .get_lib::<byond515_1609::ByondApi>().$function($($arg),*),
            (515, 1610) => $self
                .get_lib::<byond515_1610::ByondApi>().$function($($arg),*),
            (515, 1611..=1612) => $self
                .get_lib::<byond515_1611::ByondApi>().$function($($arg),*),
            x => panic!("Unknown byond version {:?}", x),
        }
    };
}

/// 1610+ only APIs
macro_rules! generate_match_1610 {
    ($self: ident, $function: ident $(, $arg:expr)*) => {
        match $self.version {
            (515, 1610) => $self
                .get_lib::<byond515_1610::ByondApi>().$function($($arg),*),
            (515, 1611..=1612) => $self
                .get_lib::<byond515_1611::ByondApi>().$function($($arg),*),
            x => panic!("Unsupported byond version for {:?}- {:?}", stringify!($function), x),
        }
    };
}

/// 1611+ only APIs
macro_rules! generate_match_1611 {
    ($self: ident, $function: ident $(, $arg:expr)*) => {
        match $self.version {
            (515, 1611..=1612) => $self
                .get_lib::<byond515_1611::ByondApi>().$function($($arg),*),
            x => panic!("Unsupported byond version for {:?}- {:?}", stringify!($function), x),
        }
    };
}

// Stabilized functions
impl ByondApi {
    pub unsafe fn Byond_GetVersion(&self, version: *mut u4c, build: *mut u4c) {
        generate_match!(self, Byond_GetVersion, version, build)
    }
    pub unsafe fn Byond_LastError(&self) -> *const c_char {
        generate_match!(self, Byond_LastError)
    }
    pub unsafe fn ByondValue_Init(&self, v: *mut CByondValue) {
        generate_match!(self, ByondValue_Init, v.cast())
    }
    pub unsafe fn ByondValue_InitNum(&self, v: *mut CByondValue, num: c_float) {
        generate_match!(self, ByondValue_InitNum, v.cast(), num)
    }
    pub unsafe fn ByondValue_InitStr(&self, v: *mut CByondValue, str_: *const c_char) -> bool {
        generate_match!(self, ByondValue_InitStr, v.cast(), str_)
    }
    pub unsafe fn ByondValue_InitRef(&self, v: *mut CByondValue, type_: ByondValueType, ref_: u4c) {
        generate_match!(self, ByondValue_InitRef, v.cast(), type_, ref_)
    }
    pub unsafe fn ByondValue_Free(&self, v: *mut CByondValue) {
        generate_match!(self, ByondValue_Free, v.cast())
    }
    pub unsafe fn ByondValue_CopyFrom(&self, dst: *mut CByondValue, src: *const CByondValue) {
        generate_match!(self, ByondValue_CopyFrom, dst.cast(), src.cast())
    }
    pub unsafe fn ByondValue_MoveFrom(&self, dst: *mut CByondValue, src: *mut CByondValue) {
        generate_match!(self, ByondValue_MoveFrom, dst.cast(), src.cast())
    }
    pub unsafe fn ByondValue_Type(&self, v: *const CByondValue) -> ByondValueType {
        generate_match!(self, ByondValue_Type, v.cast())
    }
    pub unsafe fn ByondValue_IsNull(&self, v: *const CByondValue) -> bool {
        generate_match!(self, ByondValue_IsNull, v.cast())
    }
    pub unsafe fn ByondValue_IsNum(&self, v: *const CByondValue) -> bool {
        generate_match!(self, ByondValue_IsNum, v.cast())
    }
    pub unsafe fn ByondValue_IsStr(&self, v: *const CByondValue) -> bool {
        generate_match!(self, ByondValue_IsStr, v.cast())
    }
    pub unsafe fn ByondValue_IsList(&self, v: *const CByondValue) -> bool {
        generate_match!(self, ByondValue_IsList, v.cast())
    }
    pub unsafe fn ByondValue_GetNum(&self, v: *const CByondValue) -> f32 {
        generate_match!(self, ByondValue_GetNum, v.cast())
    }
    pub unsafe fn ByondValue_GetStr(&self, v: *const CByondValue) -> *const ::std::os::raw::c_char {
        generate_match!(self, ByondValue_GetStr, v.cast())
    }
    pub unsafe fn ByondValue_GetRef(&self, v: *const CByondValue) -> u4c {
        generate_match!(self, ByondValue_GetRef, v.cast())
    }
    pub unsafe fn ByondValue_SetNum(&self, v: *mut CByondValue, f: f32) {
        generate_match!(self, ByondValue_SetNum, v.cast(), f)
    }
    pub unsafe fn ByondValue_SetStr(
        &self,
        v: *mut CByondValue,
        str_: *const ::std::os::raw::c_char,
    ) -> bool {
        generate_match!(self, ByondValue_SetStr, v.cast(), str_)
    }
    pub unsafe fn ByondValue_SetRef(&self, v: *mut CByondValue, type_: ByondValueType, ref_: u4c) {
        generate_match!(self, ByondValue_SetRef, v.cast(), type_, ref_)
    }
    pub unsafe fn ByondValue_Equals(&self, a: *const CByondValue, b: *const CByondValue) -> bool {
        generate_match!(self, ByondValue_Equals, a.cast(), b.cast())
    }
    pub unsafe fn ByondValueList_Init(&self, list: *mut CByondValueList) {
        generate_match!(self, ByondValueList_Init, list.cast())
    }
    pub unsafe fn ByondValueList_InitCount(&self, list: *mut CByondValueList, count: u4c) -> bool {
        generate_match!(self, ByondValueList_InitCount, list.cast(), count)
    }
    pub unsafe fn ByondValueList_Free(&self, list: *mut CByondValueList) {
        generate_match!(self, ByondValueList_Free, list.cast())
    }
    pub unsafe fn ByondValueList_CopyFrom(
        &self,
        dst: *mut CByondValueList,
        src: *const CByondValueList,
    ) -> bool {
        generate_match!(self, ByondValueList_CopyFrom, dst.cast(), src.cast())
    }
    pub unsafe fn ByondValueList_MoveFrom(
        &self,
        dst: *mut CByondValueList,
        src: *mut CByondValueList,
    ) {
        generate_match!(self, ByondValueList_MoveFrom, dst.cast(), src.cast())
    }
    pub unsafe fn ByondValueList_SetCount(&self, list: *mut CByondValueList, count: u4c) -> bool {
        generate_match!(self, ByondValueList_SetCount, list.cast(), count)
    }
    pub unsafe fn ByondValueList_SetCapacity(
        &self,
        list: *mut CByondValueList,
        capacity: u4c,
    ) -> bool {
        generate_match_1611!(self, ByondValueList_SetCapacity, list.cast(), capacity)
    }
    pub unsafe fn ByondValueList_Add(
        &self,
        list: *mut CByondValueList,
        v: *const CByondValue,
    ) -> bool {
        generate_match!(self, ByondValueList_Add, list.cast(), v.cast())
    }
    pub unsafe fn ByondValueList_InsertAt(
        &self,
        list: *mut CByondValueList,
        idx: ::std::os::raw::c_int,
        v: *const CByondValue,
    ) -> bool {
        generate_match!(self, ByondValueList_InsertAt, list.cast(), idx, v.cast())
    }
    pub unsafe fn ByondValueList_Splice(
        &self,
        list: *mut CByondValueList,
        idx: ::std::os::raw::c_int,
        delete_count: u4c,
        v: *const CByondValue,
        insert_count: u4c,
    ) -> bool {
        generate_match!(
            self,
            ByondValueList_Splice,
            list.cast(),
            idx,
            delete_count,
            v.cast(),
            insert_count
        )
    }
    pub unsafe fn ByondValueList_RemoveAt(
        &self,
        list: *mut CByondValueList,
        idx: u4c,
        n: u4c,
    ) -> u4c {
        generate_match!(self, ByondValueList_RemoveAt, list.cast(), idx, n)
    }
    pub unsafe fn Byond_GetStrId(&self, str_: *const ::std::os::raw::c_char) -> u4c {
        generate_match!(self, Byond_GetStrId, str_)
    }
    pub unsafe fn Byond_ReadVar(
        &self,
        loc: *const CByondValue,
        varname: *const ::std::os::raw::c_char,
        result: *mut CByondValue,
    ) -> bool {
        generate_match!(self, Byond_ReadVar, loc.cast(), varname, result.cast())
    }
    pub unsafe fn Byond_ReadVarByStrId(
        &self,
        loc: *const CByondValue,
        varname: u4c,
        result: *mut CByondValue,
    ) -> bool {
        generate_match!(
            self,
            Byond_ReadVarByStrId,
            loc.cast(),
            varname,
            result.cast()
        )
    }
    pub unsafe fn Byond_WriteVar(
        &self,
        loc: *const CByondValue,
        varname: *const ::std::os::raw::c_char,
        val: *const CByondValue,
    ) -> bool {
        generate_match!(self, Byond_WriteVar, loc.cast(), varname, val.cast())
    }
    pub unsafe fn Byond_WriteVarByStrId(
        &self,
        loc: *const CByondValue,
        varname: u4c,
        val: *const CByondValue,
    ) -> bool {
        generate_match!(self, Byond_WriteVarByStrId, loc.cast(), varname, val.cast())
    }
    pub unsafe fn Byond_CreateList(&self, result: *mut CByondValue) -> bool {
        generate_match!(self, Byond_CreateList, result.cast())
    }
    pub unsafe fn Byond_ReadList(
        &self,
        loc: *const CByondValue,
        list: *mut CByondValueList,
    ) -> bool {
        generate_match!(self, Byond_ReadList, loc.cast(), list.cast())
    }
    pub unsafe fn Byond_WriteList(
        &self,
        loc: *const CByondValue,
        list: *const CByondValueList,
    ) -> bool {
        generate_match!(self, Byond_WriteList, loc.cast(), list.cast())
    }
    pub unsafe fn Byond_ReadListIndex(
        &self,
        loc: *const CByondValue,
        idx: *const CByondValue,
        result: *mut CByondValue,
    ) -> bool {
        generate_match!(
            self,
            Byond_ReadListIndex,
            loc.cast(),
            idx.cast(),
            result.cast()
        )
    }
    pub unsafe fn Byond_WriteListIndex(
        &self,
        loc: *const CByondValue,
        idx: *const CByondValue,
        val: *const CByondValue,
    ) -> bool {
        generate_match!(
            self,
            Byond_WriteListIndex,
            loc.cast(),
            idx.cast(),
            val.cast()
        )
    }
    pub unsafe fn Byond_ReadPointer(
        &self,
        ptr: *const CByondValue,
        result: *mut CByondValue,
    ) -> bool {
        generate_match!(self, Byond_ReadPointer, ptr.cast(), result.cast())
    }
    pub unsafe fn Byond_WritePointer(
        &self,
        ptr: *const CByondValue,
        val: *const CByondValue,
    ) -> bool {
        generate_match!(self, Byond_WritePointer, ptr.cast(), val.cast())
    }
    pub unsafe fn Byond_CallProc(
        &self,
        src: *const CByondValue,
        name: *const ::std::os::raw::c_char,
        arg: *const CByondValue,
        arg_count: u4c,
        result: *mut CByondValue,
    ) -> bool {
        generate_match!(
            self,
            Byond_CallProc,
            src.cast(),
            name,
            arg.cast(),
            arg_count,
            result.cast()
        )
    }
    pub unsafe fn Byond_CallProcByStrId(
        &self,
        src: *const CByondValue,
        name: u4c,
        arg: *const CByondValue,
        arg_count: u4c,
        result: *mut CByondValue,
    ) -> bool {
        generate_match!(
            self,
            Byond_CallProcByStrId,
            src.cast(),
            name,
            arg.cast(),
            arg_count,
            result.cast()
        )
    }
    pub unsafe fn Byond_ToString(&self, src: *const CByondValue, result: *mut CByondValue) -> bool {
        generate_match_1610!(self, Byond_ToString, src.cast(), result.cast())
    }
    pub unsafe fn Byond_Block(
        &self,
        corner1: *const CByondXYZ,
        corner2: *const CByondXYZ,
        result: *mut CByondValueList,
    ) -> bool {
        generate_match_1611!(
            self,
            Byond_Block,
            corner1.cast(),
            corner2.cast(),
            result.cast()
        )
    }
    pub unsafe fn Byond_Length(&self, src: *const CByondValue, result: *mut CByondValue) -> bool {
        generate_match_1611!(self, Byond_Length, src.cast(), result.cast())
    }
    pub unsafe fn Byond_LocateIn(
        &self,
        type_: *const CByondValue,
        list: *const CByondValue,
        result: *mut CByondValue,
    ) -> bool {
        generate_match_1611!(
            self,
            Byond_LocateIn,
            type_.cast(),
            list.cast(),
            result.cast()
        )
    }
    pub unsafe fn Byond_LocateXYZ(&self, xyz: *const CByondXYZ, result: *mut CByondValue) -> bool {
        generate_match_1611!(self, Byond_LocateXYZ, xyz.cast(), result.cast())
    }
    pub unsafe fn Byond_New(
        &self,
        type_: *const CByondValue,
        argA: *const CByondValue,
        argS: u4c,
        result: *mut CByondValue,
    ) -> bool {
        generate_match_1611!(
            self,
            Byond_New,
            type_.cast(),
            argA.cast(),
            argS,
            result.cast()
        )
    }
    pub unsafe fn Byond_NewArglist(
        &self,
        type_: *const CByondValue,
        arglist: *const CByondValue,
        result: *mut CByondValue,
    ) -> bool {
        generate_match_1611!(
            self,
            Byond_NewArglist,
            type_.cast(),
            arglist.cast(),
            result.cast()
        )
    }
    pub unsafe fn Byond_Refcount(
        &self,
        type_: *const CByondValue,
        result: *mut CByondValue,
    ) -> bool {
        generate_match_1611!(self, Byond_Refcount, type_.cast(), result.cast())
    }
    pub unsafe fn Byond_XYZ(&self, src: *const CByondValue, xyz: *mut CByondXYZ) -> bool {
        generate_match_1611!(self, Byond_XYZ, src.cast(), xyz.cast())
    }
    pub unsafe fn ByondValue_IncRef(&self, src: *const CByondValue) {
        generate_match!(self, ByondValue_IncRef, src.cast())
    }
    pub unsafe fn ByondValue_DecRef(&self, src: *const CByondValue) {
        generate_match!(self, ByondValue_DecRef, src.cast())
    }
    pub unsafe fn Byond_TestRef(&self, src: *mut CByondValue) -> bool {
        generate_match!(self, Byond_TestRef, src.cast())
    }
}
